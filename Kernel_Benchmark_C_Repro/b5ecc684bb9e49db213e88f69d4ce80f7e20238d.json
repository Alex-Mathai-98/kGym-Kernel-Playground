{
    "version": 1,
    "title": "possible deadlock in nci_start_poll",
    "display-title": "possible deadlock in nci_start_poll",
    "id": "b5ecc684bb9e49db213e88f69d4ce80f7e20238d",
    "status": "fixed",
    "fix-commits": [
        {
            "title": "NFC: nci: Allow to create multiple virtual nci devices",
            "link": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b2e44aac91b25abbed57d785089c4b7af926a7bd",
            "hash": "b2e44aac91b25abbed57d785089c4b7af926a7bd",
            "repo": "git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git",
            "branch": "master"
        }
    ],
    "discussions": [
        "https://lore.kernel.org/all/000000000000e8fd1f05ed75bf20@google.com/T/"
    ],
    "crashes": [
        {
            "title": "possible deadlock in nci_start_poll",
            "syz-reproducer": "/text?tag=ReproSyz&x=177ba9ae880000",
            "c-reproducer": "/text?tag=ReproC&x=17458169880000",
            "kernel-config": "/text?tag=KernelConfig&x=31242cbb858881d2",
            "kernel-source-git": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=094226ad94f471a9f19e8f8e7140a09c2625abaa",
            "kernel-source-commit": "094226ad94f471a9f19e8f8e7140a09c2625abaa",
            "syzkaller-git": "https://github.com/google/syzkaller/commits/943f4cb8411ec16e466b0bb48bd6bcdbc526f442",
            "syzkaller-commit": "943f4cb8411ec16e466b0bb48bd6bcdbc526f442",
            "compiler-description": "Debian clang version 13.0.1-++20220126092033+75e33f71c2da-1~exp1~20220126212112.63, GNU ld (GNU Binutils for Debian) 2.35.2",
            "architecture": "amd64",
            "crash-report-link": "/text?tag=CrashReport&x=171296b9880000"
        }
    ],
    "subsystems": [
        "net",
        "nfc"
    ],
    "parent_of_fix_commit": "710cfc6ab4b85ac5388828b4be63a5f20c8a9dd9",
    "patch": "diff --git a/drivers/nfc/virtual_ncidev.c b/drivers/nfc/virtual_ncidev.c\nindex 85c06dbb2c44..bb76c7c7cc82 100644\n--- a/drivers/nfc/virtual_ncidev.c\n+++ b/drivers/nfc/virtual_ncidev.c\n@@ -13,12 +13,6 @@\n #include <linux/wait.h>\n #include <net/nfc/nci_core.h>\n \n-enum virtual_ncidev_mode {\n-\tvirtual_ncidev_enabled,\n-\tvirtual_ncidev_disabled,\n-\tvirtual_ncidev_disabling,\n-};\n-\n #define IOCTL_GET_NCIDEV_IDX    0\n #define VIRTUAL_NFC_PROTOCOLS\t(NFC_PROTO_JEWEL_MASK | \\\n \t\t\t\t NFC_PROTO_MIFARE_MASK | \\\n@@ -27,12 +21,12 @@ enum virtual_ncidev_mode {\n \t\t\t\t NFC_PROTO_ISO14443_B_MASK | \\\n \t\t\t\t NFC_PROTO_ISO15693_MASK)\n \n-static enum virtual_ncidev_mode state;\n-static DECLARE_WAIT_QUEUE_HEAD(wq);\n-static struct miscdevice miscdev;\n-static struct sk_buff *send_buff;\n-static struct nci_dev *ndev;\n-static DEFINE_MUTEX(nci_mutex);\n+struct virtual_nci_dev {\n+\tstruct nci_dev *ndev;\n+\tstruct mutex mtx;\n+\tstruct sk_buff *send_buff;\n+\tstruct wait_queue_head wq;\n+};\n \n static int virtual_nci_open(struct nci_dev *ndev)\n {\n@@ -41,31 +35,34 @@ static int virtual_nci_open(struct nci_dev *ndev)\n \n static int virtual_nci_close(struct nci_dev *ndev)\n {\n-\tmutex_lock(&nci_mutex);\n-\tkfree_skb(send_buff);\n-\tsend_buff = NULL;\n-\tmutex_unlock(&nci_mutex);\n+\tstruct virtual_nci_dev *vdev = nci_get_drvdata(ndev);\n+\n+\tmutex_lock(&vdev->mtx);\n+\tkfree_skb(vdev->send_buff);\n+\tvdev->send_buff = NULL;\n+\tmutex_unlock(&vdev->mtx);\n \n \treturn 0;\n }\n \n static int virtual_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n {\n-\tmutex_lock(&nci_mutex);\n-\tif (state != virtual_ncidev_enabled) {\n-\t\tmutex_unlock(&nci_mutex);\n+\tstruct virtual_nci_dev *vdev = nci_get_drvdata(ndev);\n+\n+\tmutex_lock(&vdev->mtx);\n+\tif (vdev->send_buff) {\n+\t\tmutex_unlock(&vdev->mtx);\n \t\tkfree_skb(skb);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n-\n-\tif (send_buff) {\n-\t\tmutex_unlock(&nci_mutex);\n+\tvdev->send_buff = skb_copy(skb, GFP_KERNEL);\n+\tif (!vdev->send_buff) {\n+\t\tmutex_unlock(&vdev->mtx);\n \t\tkfree_skb(skb);\n \t\treturn -1;\n \t}\n-\tsend_buff = skb_copy(skb, GFP_KERNEL);\n-\tmutex_unlock(&nci_mutex);\n-\twake_up_interruptible(&wq);\n+\tmutex_unlock(&vdev->mtx);\n+\twake_up_interruptible(&vdev->wq);\n \tconsume_skb(skb);\n \n \treturn 0;\n@@ -80,29 +77,30 @@ static const struct nci_ops virtual_nci_ops = {\n static ssize_t virtual_ncidev_read(struct file *file, char __user *buf,\n \t\t\t\t   size_t count, loff_t *ppos)\n {\n+\tstruct virtual_nci_dev *vdev = file->private_data;\n \tsize_t actual_len;\n \n-\tmutex_lock(&nci_mutex);\n-\twhile (!send_buff) {\n-\t\tmutex_unlock(&nci_mutex);\n-\t\tif (wait_event_interruptible(wq, send_buff))\n+\tmutex_lock(&vdev->mtx);\n+\twhile (!vdev->send_buff) {\n+\t\tmutex_unlock(&vdev->mtx);\n+\t\tif (wait_event_interruptible(vdev->wq, vdev->send_buff))\n \t\t\treturn -EFAULT;\n-\t\tmutex_lock(&nci_mutex);\n+\t\tmutex_lock(&vdev->mtx);\n \t}\n \n-\tactual_len = min_t(size_t, count, send_buff->len);\n+\tactual_len = min_t(size_t, count, vdev->send_buff->len);\n \n-\tif (copy_to_user(buf, send_buff->data, actual_len)) {\n-\t\tmutex_unlock(&nci_mutex);\n+\tif (copy_to_user(buf, vdev->send_buff->data, actual_len)) {\n+\t\tmutex_unlock(&vdev->mtx);\n \t\treturn -EFAULT;\n \t}\n \n-\tskb_pull(send_buff, actual_len);\n-\tif (send_buff->len == 0) {\n-\t\tconsume_skb(send_buff);\n-\t\tsend_buff = NULL;\n+\tskb_pull(vdev->send_buff, actual_len);\n+\tif (vdev->send_buff->len == 0) {\n+\t\tconsume_skb(vdev->send_buff);\n+\t\tvdev->send_buff = NULL;\n \t}\n-\tmutex_unlock(&nci_mutex);\n+\tmutex_unlock(&vdev->mtx);\n \n \treturn actual_len;\n }\n@@ -111,6 +109,7 @@ static ssize_t virtual_ncidev_write(struct file *file,\n \t\t\t\t    const char __user *buf,\n \t\t\t\t    size_t count, loff_t *ppos)\n {\n+\tstruct virtual_nci_dev *vdev = file->private_data;\n \tstruct sk_buff *skb;\n \n \tskb = alloc_skb(count, GFP_KERNEL);\n@@ -122,63 +121,58 @@ static ssize_t virtual_ncidev_write(struct file *file,\n \t\treturn -EFAULT;\n \t}\n \n-\tnci_recv_frame(ndev, skb);\n+\tnci_recv_frame(vdev->ndev, skb);\n \treturn count;\n }\n \n static int virtual_ncidev_open(struct inode *inode, struct file *file)\n {\n \tint ret = 0;\n+\tstruct virtual_nci_dev *vdev;\n \n-\tmutex_lock(&nci_mutex);\n-\tif (state != virtual_ncidev_disabled) {\n-\t\tmutex_unlock(&nci_mutex);\n-\t\treturn -EBUSY;\n-\t}\n-\n-\tndev = nci_allocate_device(&virtual_nci_ops, VIRTUAL_NFC_PROTOCOLS,\n-\t\t\t\t   0, 0);\n-\tif (!ndev) {\n-\t\tmutex_unlock(&nci_mutex);\n+\tvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\n+\tif (!vdev)\n+\t\treturn -ENOMEM;\n+\tvdev->ndev = nci_allocate_device(&virtual_nci_ops,\n+\t\tVIRTUAL_NFC_PROTOCOLS, 0, 0);\n+\tif (!vdev->ndev) {\n+\t\tkfree(vdev);\n \t\treturn -ENOMEM;\n \t}\n \n-\tret = nci_register_device(ndev);\n+\tmutex_init(&vdev->mtx);\n+\tinit_waitqueue_head(&vdev->wq);\n+\tfile->private_data = vdev;\n+\tnci_set_drvdata(vdev->ndev, vdev);\n+\n+\tret = nci_register_device(vdev->ndev);\n \tif (ret < 0) {\n-\t\tnci_free_device(ndev);\n-\t\tmutex_unlock(&nci_mutex);\n+\t\tnci_free_device(vdev->ndev);\n+\t\tmutex_destroy(&vdev->mtx);\n+\t\tkfree(vdev);\n \t\treturn ret;\n \t}\n-\tstate = virtual_ncidev_enabled;\n-\tmutex_unlock(&nci_mutex);\n \n \treturn 0;\n }\n \n static int virtual_ncidev_close(struct inode *inode, struct file *file)\n {\n-\tmutex_lock(&nci_mutex);\n-\n-\tif (state == virtual_ncidev_enabled) {\n-\t\tstate = virtual_ncidev_disabling;\n-\t\tmutex_unlock(&nci_mutex);\n+\tstruct virtual_nci_dev *vdev = file->private_data;\n \n-\t\tnci_unregister_device(ndev);\n-\t\tnci_free_device(ndev);\n-\n-\t\tmutex_lock(&nci_mutex);\n-\t}\n-\n-\tstate = virtual_ncidev_disabled;\n-\tmutex_unlock(&nci_mutex);\n+\tnci_unregister_device(vdev->ndev);\n+\tnci_free_device(vdev->ndev);\n+\tmutex_destroy(&vdev->mtx);\n+\tkfree(vdev);\n \n \treturn 0;\n }\n \n-static long virtual_ncidev_ioctl(struct file *flip, unsigned int cmd,\n+static long virtual_ncidev_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n-\tconst struct nfc_dev *nfc_dev = ndev->nfc_dev;\n+\tstruct virtual_nci_dev *vdev = file->private_data;\n+\tconst struct nfc_dev *nfc_dev = vdev->ndev->nfc_dev;\n \tvoid __user *p = (void __user *)arg;\n \n \tif (cmd != IOCTL_GET_NCIDEV_IDX)\n@@ -199,14 +193,15 @@ static const struct file_operations virtual_ncidev_fops = {\n \t.unlocked_ioctl = virtual_ncidev_ioctl\n };\n \n+static struct miscdevice miscdev = {\n+\t.minor = MISC_DYNAMIC_MINOR,\n+\t.name = \"virtual_nci\",\n+\t.fops = &virtual_ncidev_fops,\n+\t.mode = 0600,\n+};\n+\n static int __init virtual_ncidev_init(void)\n {\n-\tstate = virtual_ncidev_disabled;\n-\tmiscdev.minor = MISC_DYNAMIC_MINOR;\n-\tmiscdev.name = \"virtual_nci\";\n-\tmiscdev.fops = &virtual_ncidev_fops;\n-\tmiscdev.mode = 0600;\n-\n \treturn misc_register(&miscdev);\n }\n \n",
    "patch_modified_files": [
        "drivers/nfc/virtual_ncidev.c"
    ]
}