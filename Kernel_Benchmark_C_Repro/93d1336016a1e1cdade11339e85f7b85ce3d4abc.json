{
    "version": 1,
    "title": "KASAN: slab-out-of-bounds Read in find_first_zero_bit",
    "display-title": "KASAN: slab-out-of-bounds Read in find_first_zero_bit",
    "id": "93d1336016a1e1cdade11339e85f7b85ce3d4abc",
    "status": "fixed",
    "fix-commits": [
        {
            "title": "bfs: extra sanity checking and static inode bitmap",
            "link": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d1877155891020cb26ad4fba45bfee52d8da9951",
            "hash": "d1877155891020cb26ad4fba45bfee52d8da9951",
            "repo": "git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git",
            "branch": "master"
        }
    ],
    "discussions": [
        "https://lore.kernel.org/all/001a113ed49eb535d20568bb75ba@google.com/T/",
        "https://lore.kernel.org/all/001a113fe6c0bfcfa90568bb75bd@google.com/T/",
        "https://lore.kernel.org/all/CAK+_RLmumEQBCEEoVaXdV3i4jW+a1mPBsihdCJcVK=anpXWgyw@mail.gmail.com/T/"
    ],
    "crashes": [
        {
            "title": "",
            "syz-reproducer": "/text?tag=ReproSyz&x=16cf65d3800000",
            "c-reproducer": "/text?tag=ReproC&x=16d99ab3800000",
            "kernel-config": "/text?tag=KernelConfig&x=d9b0d91297e224bc",
            "kernel-source-git": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=b5dbc28762fd3fd40ba76303be0c7f707826f982",
            "kernel-source-commit": "b5dbc28762fd3fd40ba76303be0c7f707826f982",
            "syzkaller-git": "https://github.com/google/syzkaller/commits/8fbce0e4423f701145e111531f6f41cc02e086cf",
            "syzkaller-commit": "8fbce0e4423f701145e111531f6f41cc02e086cf",
            "compiler-description": "gcc (GCC) 7.1.1 20170620",
            "architecture": "amd64",
            "crash-report-link": "/text?tag=CrashReport&x=1161c30b800000"
        }
    ],
    "subsystems": [
        "bfs"
    ],
    "parent_of_fix_commit": "655c16a8ce9c15842547f40ce23fd148aeccc074",
    "patch": "diff --git a/fs/bfs/bfs.h b/fs/bfs/bfs.h\nindex 67aef3bb89e4..606f9378b2f0 100644\n--- a/fs/bfs/bfs.h\n+++ b/fs/bfs/bfs.h\n@@ -1,13 +1,20 @@\n /* SPDX-License-Identifier: GPL-2.0 */\n /*\n  *\tfs/bfs/bfs.h\n- *\tCopyright (C) 1999 Tigran Aivazian <tigran@veritas.com>\n+ *\tCopyright (C) 1999-2018 Tigran Aivazian <aivazian.tigran@gmail.com>\n  */\n #ifndef _FS_BFS_BFS_H\n #define _FS_BFS_BFS_H\n \n #include <linux/bfs_fs.h>\n \n+/* In theory BFS supports up to 512 inodes, numbered from 2 (for /) up to 513 inclusive.\n+   In actual fact, attempting to create the 512th inode (i.e. inode No. 513 or file No. 511)\n+   will fail with ENOSPC in bfs_add_entry(): the root directory cannot contain so many entries, counting '..'.\n+   So, mkfs.bfs(8) should really limit its -N option to 511 and not 512. For now, we just print a warning\n+   if a filesystem is mounted with such \"impossible to fill up\" number of inodes */\n+#define BFS_MAX_LASTI\t513\n+\n /*\n  * BFS file system in-core superblock info\n  */\n@@ -17,7 +24,7 @@ struct bfs_sb_info {\n \tunsigned long si_freei;\n \tunsigned long si_lf_eblk;\n \tunsigned long si_lasti;\n-\tunsigned long *si_imap;\n+\tDECLARE_BITMAP(si_imap, BFS_MAX_LASTI+1);\n \tstruct mutex bfs_lock;\n };\n \ndiff --git a/fs/bfs/dir.c b/fs/bfs/dir.c\nindex f32f21c3bbc7..d8dfe3a0cb39 100644\n--- a/fs/bfs/dir.c\n+++ b/fs/bfs/dir.c\n@@ -2,8 +2,8 @@\n /*\n  *\tfs/bfs/dir.c\n  *\tBFS directory operations.\n- *\tCopyright (C) 1999,2000  Tigran Aivazian <tigran@veritas.com>\n- *      Made endianness-clean by Andrew Stribblehill <ads@wompom.org> 2005\n+ *\tCopyright (C) 1999-2018  Tigran Aivazian <aivazian.tigran@gmail.com>\n+ *  Made endianness-clean by Andrew Stribblehill <ads@wompom.org> 2005\n  */\n \n #include <linux/time.h>\ndiff --git a/fs/bfs/file.c b/fs/bfs/file.c\nindex 1476cdd90cfb..0dceefc54b48 100644\n--- a/fs/bfs/file.c\n+++ b/fs/bfs/file.c\n@@ -2,7 +2,7 @@\n /*\n  *\tfs/bfs/file.c\n  *\tBFS file operations.\n- *\tCopyright (C) 1999,2000 Tigran Aivazian <tigran@veritas.com>\n+ *\tCopyright (C) 1999-2018 Tigran Aivazian <aivazian.tigran@gmail.com>\n  *\n  *\tMake the file block allocation algorithm understand the size\n  *\tof the underlying block device.\ndiff --git a/fs/bfs/inode.c b/fs/bfs/inode.c\nindex d81c148682e7..d136b2aaafb3 100644\n--- a/fs/bfs/inode.c\n+++ b/fs/bfs/inode.c\n@@ -1,10 +1,9 @@\n /*\n  *\tfs/bfs/inode.c\n  *\tBFS superblock and inode operations.\n- *\tCopyright (C) 1999-2006 Tigran Aivazian <aivazian.tigran@gmail.com>\n+ *\tCopyright (C) 1999-2018 Tigran Aivazian <aivazian.tigran@gmail.com>\n  *\tFrom fs/minix, Copyright (C) 1991, 1992 Linus Torvalds.\n- *\n- *      Made endianness-clean by Andrew Stribblehill <ads@wompom.org>, 2005.\n+ *\tMade endianness-clean by Andrew Stribblehill <ads@wompom.org>, 2005.\n  */\n \n #include <linux/module.h>\n@@ -118,12 +117,12 @@ static int bfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n {\n \tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n \tunsigned int ino = (u16)inode->i_ino;\n-        unsigned long i_sblock;\n+\tunsigned long i_sblock;\n \tstruct bfs_inode *di;\n \tstruct buffer_head *bh;\n \tint err = 0;\n \n-        dprintf(\"ino=%08x\\n\", ino);\n+\tdprintf(\"ino=%08x\\n\", ino);\n \n \tdi = find_inode(inode->i_sb, ino, &bh);\n \tif (IS_ERR(di))\n@@ -144,7 +143,7 @@ static int bfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n \tdi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n \tdi->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n \tdi->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n-        i_sblock = BFS_I(inode)->i_sblock;\n+\ti_sblock = BFS_I(inode)->i_sblock;\n \tdi->i_sblock = cpu_to_le32(i_sblock);\n \tdi->i_eblock = cpu_to_le32(BFS_I(inode)->i_eblock);\n \tdi->i_eoffset = cpu_to_le32(i_sblock * BFS_BSIZE + inode->i_size - 1);\n@@ -188,13 +187,13 @@ static void bfs_evict_inode(struct inode *inode)\n \tmark_buffer_dirty(bh);\n \tbrelse(bh);\n \n-        if (bi->i_dsk_ino) {\n+\tif (bi->i_dsk_ino) {\n \t\tif (bi->i_sblock)\n \t\t\tinfo->si_freeb += bi->i_eblock + 1 - bi->i_sblock;\n \t\tinfo->si_freei++;\n \t\tclear_bit(ino, info->si_imap);\n-\t\tbfs_dump_imap(\"delete_inode\", s);\n-        }\n+\t\tbfs_dump_imap(\"evict_inode\", s);\n+\t}\n \n \t/*\n \t * If this was the last file, make the previous block\n@@ -214,7 +213,6 @@ static void bfs_put_super(struct super_block *s)\n \t\treturn;\n \n \tmutex_destroy(&info->bfs_lock);\n-\tkfree(info->si_imap);\n \tkfree(info);\n \ts->s_fs_info = NULL;\n }\n@@ -311,8 +309,7 @@ void bfs_dump_imap(const char *prefix, struct super_block *s)\n \t\telse\n \t\t\tstrcat(tmpbuf, \"0\");\n \t}\n-\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n-\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n+\tprintf(\"%s: lasti=%08lx <%s>\\n\", prefix, BFS_SB(s)->si_lasti, tmpbuf);\n \tfree_page((unsigned long)tmpbuf);\n #endif\n }\n@@ -322,7 +319,7 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \tstruct buffer_head *bh, *sbh;\n \tstruct bfs_super_block *bfs_sb;\n \tstruct inode *inode;\n-\tunsigned i, imap_len;\n+\tunsigned i;\n \tstruct bfs_sb_info *info;\n \tint ret = -EINVAL;\n \tunsigned long i_sblock, i_eblock, i_eoff, s_size;\n@@ -341,8 +338,7 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \tbfs_sb = (struct bfs_super_block *)sbh->b_data;\n \tif (le32_to_cpu(bfs_sb->s_magic) != BFS_MAGIC) {\n \t\tif (!silent)\n-\t\t\tprintf(\"No BFS filesystem on %s (magic=%08x)\\n\", \n-\t\t\t\ts->s_id,  le32_to_cpu(bfs_sb->s_magic));\n+\t\t\tprintf(\"No BFS filesystem on %s (magic=%08x)\\n\", s->s_id,  le32_to_cpu(bfs_sb->s_magic));\n \t\tgoto out1;\n \t}\n \tif (BFS_UNCLEAN(bfs_sb, s) && !silent)\n@@ -351,18 +347,16 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \ts->s_magic = BFS_MAGIC;\n \n \tif (le32_to_cpu(bfs_sb->s_start) > le32_to_cpu(bfs_sb->s_end) ||\n-\t    le32_to_cpu(bfs_sb->s_start) < BFS_BSIZE) {\n-\t\tprintf(\"Superblock is corrupted\\n\");\n+\t    le32_to_cpu(bfs_sb->s_start) < sizeof(struct bfs_super_block) + sizeof(struct bfs_dirent)) {\n+\t\tprintf(\"Superblock is corrupted on %s\\n\", s->s_id);\n \t\tgoto out1;\n \t}\n \n-\tinfo->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) /\n-\t\t\t\t\tsizeof(struct bfs_inode)\n-\t\t\t\t\t+ BFS_ROOT_INO - 1;\n-\timap_len = (info->si_lasti / 8) + 1;\n-\tinfo->si_imap = kzalloc(imap_len, GFP_KERNEL | __GFP_NOWARN);\n-\tif (!info->si_imap) {\n-\t\tprintf(\"Cannot allocate %u bytes\\n\", imap_len);\n+\tinfo->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) / sizeof(struct bfs_inode) + BFS_ROOT_INO - 1;\n+\tif (info->si_lasti == BFS_MAX_LASTI)\n+\t\tprintf(\"WARNING: filesystem %s was created with 512 inodes, the real maximum is 511, mounting anyway\\n\", s->s_id);\n+\telse if (info->si_lasti > BFS_MAX_LASTI) {\n+\t\tprintf(\"Impossible last inode number %lu > %d on %s\\n\", info->si_lasti, BFS_MAX_LASTI, s->s_id);\n \t\tgoto out1;\n \t}\n \tfor (i = 0; i < BFS_ROOT_INO; i++)\n@@ -372,26 +366,25 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \tinode = bfs_iget(s, BFS_ROOT_INO);\n \tif (IS_ERR(inode)) {\n \t\tret = PTR_ERR(inode);\n-\t\tgoto out2;\n+\t\tgoto out1;\n \t}\n \ts->s_root = d_make_root(inode);\n \tif (!s->s_root) {\n \t\tret = -ENOMEM;\n-\t\tgoto out2;\n+\t\tgoto out1;\n \t}\n \n \tinfo->si_blocks = (le32_to_cpu(bfs_sb->s_end) + 1) >> BFS_BSIZE_BITS;\n-\tinfo->si_freeb = (le32_to_cpu(bfs_sb->s_end) + 1\n-\t\t\t- le32_to_cpu(bfs_sb->s_start)) >> BFS_BSIZE_BITS;\n+\tinfo->si_freeb = (le32_to_cpu(bfs_sb->s_end) + 1 - le32_to_cpu(bfs_sb->s_start)) >> BFS_BSIZE_BITS;\n \tinfo->si_freei = 0;\n \tinfo->si_lf_eblk = 0;\n \n \t/* can we read the last block? */\n \tbh = sb_bread(s, info->si_blocks - 1);\n \tif (!bh) {\n-\t\tprintf(\"Last block not available: %lu\\n\", info->si_blocks - 1);\n+\t\tprintf(\"Last block not available on %s: %lu\\n\", s->s_id, info->si_blocks - 1);\n \t\tret = -EIO;\n-\t\tgoto out3;\n+\t\tgoto out2;\n \t}\n \tbrelse(bh);\n \n@@ -425,11 +418,11 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \t\t\t(i_eoff != le32_to_cpu(-1) && i_eoff > s_size) ||\n \t\t\ti_sblock * BFS_BSIZE > i_eoff) {\n \n-\t\t\tprintf(\"Inode 0x%08x corrupted\\n\", i);\n+\t\t\tprintf(\"Inode 0x%08x corrupted on %s\\n\", i, s->s_id);\n \n \t\t\tbrelse(bh);\n \t\t\tret = -EIO;\n-\t\t\tgoto out3;\n+\t\t\tgoto out2;\n \t\t}\n \n \t\tif (!di->i_ino) {\n@@ -445,14 +438,12 @@ static int bfs_fill_super(struct super_block *s, void *data, int silent)\n \t}\n \tbrelse(bh);\n \tbrelse(sbh);\n-\tbfs_dump_imap(\"read_super\", s);\n+\tbfs_dump_imap(\"fill_super\", s);\n \treturn 0;\n \n-out3:\n+out2:\n \tdput(s->s_root);\n \ts->s_root = NULL;\n-out2:\n-\tkfree(info->si_imap);\n out1:\n \tbrelse(sbh);\n out:\n@@ -482,7 +473,7 @@ static int __init init_bfs_fs(void)\n \tint err = init_inodecache();\n \tif (err)\n \t\tgoto out1;\n-        err = register_filesystem(&bfs_fs_type);\n+\terr = register_filesystem(&bfs_fs_type);\n \tif (err)\n \t\tgoto out;\n \treturn 0;\ndiff --git a/include/uapi/linux/bfs_fs.h b/include/uapi/linux/bfs_fs.h\nindex 940b04772af8..08f6b4956359 100644\n--- a/include/uapi/linux/bfs_fs.h\n+++ b/include/uapi/linux/bfs_fs.h\n@@ -1,7 +1,7 @@\n /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n /*\n  *\tinclude/linux/bfs_fs.h - BFS data structures on disk.\n- *\tCopyright (C) 1999 Tigran Aivazian <tigran@veritas.com>\n+ *\tCopyright (C) 1999-2018 Tigran Aivazian <aivazian.tigran@gmail.com>\n  */\n \n #ifndef _LINUX_BFS_FS_H\n",
    "patch_modified_files": [
        "fs/bfs/bfs.h",
        "fs/bfs/dir.c",
        "fs/bfs/file.c",
        "fs/bfs/inode.c",
        "include/uapi/linux/bfs_fs.h"
    ]
}